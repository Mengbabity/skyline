# skyline

问题：给出轮廓的坐标。

用到的关键数据结构：C++的priority_queue，本质是堆结构。priority_queue<Type, Container, Functional>，分别为数据类型，保存数的容器，还有比较方式。
本题用到的数据类型是pair，优先级默认用first元素降序排列，first相等则用second降序排列。

思路：首先设置一个priority_queue用来存放当前正在“处理”的楼，前一项为楼的高度，后一项为楼的右X坐标。
整个过程需要在有“正在处理”的楼，或者，数组没有遍历完全的情况下进行。
1.如果没有正在处理的楼，就要取正在遍历的楼的左坐标；有处理的楼，就取最高的楼的右坐标。取高楼左坐标的原因是，我们要取高楼与矮楼相交之处的坐标，即（高楼右坐标，矮楼高度），这个数据记录为X。

2.如果遍历完成，或者正在遍历的楼的左坐标大于记录的左坐标，说明该处理的还没处理完……但之前要要取的数据都取了（下面会说明）
这时候就将将处理列表中，左坐标小于正在遍历的删掉。
否则，说明之前的处理好啦，现在要处理正在遍历的楼。将正在遍历的楼的（高度，右坐标）打包，放入处理队列。若下一个楼的左坐标和它重叠，也放入队列，因为只取最高的那个。

3.如果没有正在处理的楼，说明一堆拥挤的楼处理到了尾部，这时候高度取0；有的话，就取最高楼的高度。
当结果中末尾的高度等于这个最高楼的高度，我们不能再次放入了，因为肯定要记录的是矮楼的高度（相交之处点的坐标，高度取矮楼高度，原因同1）

算法作者解释：
1.priority_queue中首先按高度排序，其次按照右坐标。因为同样高度的只取最右。

2.两种情况：新建筑物在前一个结束之前开始（重叠），将其放入处理队列即可（上一个2的else）。加入之后取最高楼的高度。如果上一个放的就是这个高度，说明新楼比较矮，不能用这个高度，开始下一次迭代；否则说明新楼高，取它的高度就可以了，正好是左上角的点；
           建筑物隔了一段再开始，慢慢处理前面没处理好的就行了。最后处理队列没有了，保存右下角坐标，高度为0.
           
